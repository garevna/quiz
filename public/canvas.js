(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["canvas"],{

/***/ "./components/CanvasComponent.js":
/*!***************************************!*\
  !*** ./components/CanvasComponent.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst Canvas = (\"canvas-element\", {\n  props: [\"color\", \"width\", \"height\", \"imageURL\", \"text\"],\n  data: function () {\n    return {\n      mode: \"draw\",\n      canvas: document.getElementById(\"canvas\")\n    };\n  },\n  computed: {\n    mainSize() {\n      return this.dimension ? Math.min(...this.dimension.split(\",\").map(item => Number(item.trim()))) : 100;\n    },\n\n    imageWidth() {\n      return this.width ? this.width <= 200 ? this.width : 200 : 100;\n    },\n\n    imageHeight() {\n      return this.height ? this.height <= 200 ? this.height : 200 : 100;\n    },\n\n    canvasWidth() {\n      return Math.min(this.imageWidth * 2, 300);\n    },\n\n    canvasHeight() {\n      return Math.min(this.imageHeight * 2, 300);\n    },\n\n    offsetLeft() {\n      return Math.round((300 - this.imageWidth) / 2);\n    },\n\n    offsetTop() {\n      return Math.round((300 - this.imageHeight) / 2);\n    }\n\n  },\n  template: `\n      <figure style=\"width:300px;height:300px;\">\n        <canvas id=\"canvas\"\n                :width=\"canvasWidth\"\n                :height=\"canvasHeight\">\n        </canvas>\n      </figure>\n      `,\n  methods: {\n    init() {\n      this.canvas.style = `\n              position: absolute;\n              top: ${this.offsetTop}px;\n              left:${this.offsetLeft}px;\n          `;\n      this.createStaticPoints();\n      this.canvas.points = [];\n      this.staticPoints.forEach(target => this.canvas.points.push(new CanvasPoint(this.canvas, this.ctx, target)));\n    },\n\n    loop() {\n      if (this.mode) {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this[this.mode]();\n      }\n\n      requestAnimationFrame(this.loop.bind(this));\n    },\n\n    draw() {\n      if (this.mode !== \"draw\") return;\n      this.play = this.canvas.points.filter(point => point.move()).length;\n      this.mode = this.play ? \"draw\" : null;\n    },\n\n    break() {\n      if (this.mode !== \"break\") return;\n      this.mode === \"break\" ? this.play = this.canvas.points.filter(point => point.break()).length : null;\n\n      if (!this.play) {\n        this.init();\n        this.mode = \"draw\";\n      }\n    },\n\n    createStaticPoints() {\n      this.staticPoints = [];\n      let color = getComputedStyle(document.documentElement).getPropertyValue('--primary');\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      let canvasImage = document.body.appendChild(document.createElement(\"img\"));\n      canvasImage.style.display = \"none\"; // img.id = \"sourceImage\"\n\n      canvasImage.src = \"./images/js-icon.svg\";\n      let width = this.width || 80,\n          height = this.height || 80; // this.ctx.font = \"bold 100px Arial\";\n      // this.ctx.lineWidth = 2;\n      // this.ctx.strokeStyle = color;\n      // this.ctx.strokeText ( this.staticText, 50, 100 );\n\n      this.ctx.drawImage(canvasImage, 0, 0, width, height);\n      const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n      let ctxData = imageData.data;\n\n      for (let point = 0; point < ctxData.length; point += 4) {\n        if (ctxData[point] || ctxData[point + 1] || ctxData[point + 2]) {\n          this.staticPoints.push({\n            x: Math.round(point % (this.canvas.width * 4) / 4),\n            y: Math.round(point / (this.canvas.width * 4))\n          });\n        }\n      }\n    },\n\n    clickHandler() {\n      // this.staticText = this.staticText === \"JS\" ? \"âœˆ\" : \"JS\"\n      if (!this.canvas.points.length) {\n        this.init();\n        this.mode = \"draw\";\n      } else this.mode = \"break\";\n\n      this.loop();\n    }\n\n  },\n  mounted: function () {\n    this.canvas = document.getElementById(\"canvas\");\n    this.canvas.style = `\n          position: absolute;\n          bottom: 10px;\n          right:20px;\n      `;\n    canvas.width = 250;\n    canvas.height = 200;\n    this.canvas.onclick = this.clickHandler;\n    this.canvas.maxDistance = Math.min(this.canvas.width, this.canvas.height);\n    this.canvas.points = [];\n    this.staticPoints = [];\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.staticText = this.text || \"\";\n    this.init();\n    this.loop();\n  }\n});\n\nclass CanvasPoint {\n  constructor(canvas, ctx, target) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.target = target;\n    this.color = this.color ? this.color.length === 4 ? this.color.slice(1).split(\"\").map(c => parseInt(c, 16) * parseInt(c, 16)) : this.color.length === 7 ? [parseInt(color.slice(1, 3), 16), parseInt(color.slice(3, 5), 16), parseInt(color.slice(5, 7), 16)] : this.colors[Math.round(Math.random() * (this.colors.length - 1))] : this.colors[Math.round(Math.random() * (this.colors.length - 1))];\n    this.color[3] = 255;\n    Object.defineProperty(this, \"distance\", {\n      get() {\n        return Math.round(Math.sqrt(Math.pow(this.target.x - this.x, 2) + Math.pow(this.target.y - this.y, 2)));\n      },\n\n      set(radius) {\n        this.color[3] = Math.round(255 * ((this.maxDistance - radius) / this.maxDistance));\n        let angle = Math.PI / 2 * Math.random();\n        [this.x, this.y] = [this.target.x + Math.round(radius * Math.sin(angle)), this.target.y + Math.round(radius * Math.cos(angle))];\n      }\n\n    });\n    this.distance = this.maxDistance;\n    this.draw();\n  }\n\n  move() {\n    if (!this.distance) return this.draw();\n    this.distance = Math.max(0, Math.round(this.distance - this.velocity * Math.random()));\n    this.color[3] = Math.round(255 * ((this.maxDistance - this.distance) / this.maxDistance));\n    this.draw();\n    return Boolean(this.distance);\n  }\n\n  break() {\n    let angle = Math.PI / 2 * Math.random();\n    let radius = Math.round(this.velocity * Math.random());\n    [this.x, this.y] = [this.x + Math.round(radius * Math.sin(angle)), this.y + Math.round(radius * Math.cos(angle))];\n    this.color[3] = Math.round(255 * ((this.maxDistance - this.distance) / this.maxDistance));\n    this.draw();\n    return Math.max(this.maxDistance - this.distance, 0);\n  }\n\n  draw() {\n    let imageData = this.ctx.getImageData(this.x, this.y, 1, 1);\n    let point = imageData.data;\n\n    for (var index = 0; index < 4; index++) point[index] = this.color[index];\n\n    this.ctx.putImageData(imageData, this.x, this.y);\n  }\n\n}\n\nCanvasPoint.prototype.colors = [[255, 0, 255, 255], [130, 255, 130, 255], [255, 90, 0, 255], [0, 150, 200, 255], [255, 255, 170, 255]];\nCanvasPoint.prototype.velocity = 4;\nObject.defineProperty(CanvasPoint.prototype, \"maxDistance\", {\n  get() {\n    return Math.round(Math.min(this.canvas.width * 0.5, this.canvas.height * 0.5));\n  }\n\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (Canvas);\n\n//# sourceURL=webpack:///./components/CanvasComponent.js?");

/***/ })

}]);